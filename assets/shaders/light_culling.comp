#version 450

#include "set0.glsl"
#include "tiling_constants.glsl"

#extension GL_EXT_debug_printf : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 4) in;

layout(std430, set = 1, binding = 1) restrict buffer writeonly light_index_list
{
  uint light_indices[];
};

struct LightGridEntry
{
  uint offset;
  uint count;
  uint pad0;
  uint pad1;
};
layout(std430, set = 1, binding = 2) restrict buffer writeonly light_grid_buffer
{
  LightGridEntry tile_light_grids[];
};

layout(std430,
       set = 1,
       binding = 3) restrict buffer writeonly light_index_allocator
{
  uint global_light_list_counter;
};
layout(rgba8ui, set = 1, binding = 4) uniform writeonly uimage2D debug_image;

// Shared memory for light culling per workgroup
shared uint shared_light_indices[MAX_LIGHTS_PER_TILE];
shared uint shared_count;

ivec2
flatten_tile_coord(uvec3 tile_coord, uvec3 tile_grid_size)
{
  int tile_x = int(tile_coord.x) + int(tile_grid_size.x) * int(tile_coord.z);
  int tile_y = int(tile_coord.y);
  return ivec2(tile_x, tile_y);
}

uint
get_tile_index(uvec3 tile_coord, uvec3 tile_grid_size)
{
  return tile_coord.z * tile_grid_size.x * tile_grid_size.y +
         tile_coord.y * tile_grid_size.x + tile_coord.x;
}

float
linear_depth(uint slice, uint num_slices, float near_z, float far_z)
{
  float slice_z = float(slice) / float(num_slices);
  return near_z * pow(far_z / near_z, slice_z);
}

vec3
ndc_to_view(vec2 ndc, float z_clip)
{
  // No Y-axis flip for OpenGL
  vec4 clip = vec4(ndc * 2.0 - 1.0, z_clip * 2.0 - 1.0, 1.0);
  vec4 view = camera_ubo.inverse_projection * clip;
  return view.xyz / view.w;
}

// Create frustum from tile bounds and depth slice
struct Frustum
{
  vec3 corners[8];
  vec3 center;
  float radius;
};

Frustum
create_tile_frustum(vec2 tile_min,
                    vec2 tile_max,
                    float near_depth,
                    float far_depth)
{
  Frustum frustum;

  // Calculate all 8 corners of the frustum
  frustum.corners[0] = ndc_to_view(tile_min, near_depth); // near bottom-left
  frustum.corners[1] =
    ndc_to_view(vec2(tile_max.x, tile_min.y), near_depth); // near bottom-right
  frustum.corners[2] = ndc_to_view(tile_max, near_depth);  // near top-right
  frustum.corners[3] =
    ndc_to_view(vec2(tile_min.x, tile_max.y), near_depth); // near top-left
  frustum.corners[4] = ndc_to_view(tile_min, far_depth);   // far bottom-left
  frustum.corners[5] =
    ndc_to_view(vec2(tile_max.x, tile_min.y), far_depth); // far bottom-right
  frustum.corners[6] = ndc_to_view(tile_max, far_depth);  // far top-right
  frustum.corners[7] =
    ndc_to_view(vec2(tile_min.x, tile_max.y), far_depth); // far top-left

  // Calculate center as average of all corners
  frustum.center = vec3(0.0);
  for (int i = 0; i < 8; ++i) {
    frustum.center += frustum.corners[i];
  }
  frustum.center /= 8.0;

  // Calculate bounding sphere radius
  frustum.radius = 0.0;
  for (int i = 0; i < 8; ++i) {
    float dist = length(frustum.corners[i] - frustum.center);
    frustum.radius = max(frustum.radius, dist);
  }

  return frustum;
}

vec4
get_heatmap_color(uint light_count, uint max_lights)
{
  // Normalize light count to [0, 1] range
  float normalized = float(light_count) / float(max_lights);
  normalized = clamp(normalized, 0.0, 1.0);

  // Create blue->red heatmap
  vec3 color;
  if (normalized < 0.5) {
    // Blue to cyan to green (0.0 to 0.5)
    float t = normalized * 2.0;
    color = mix(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), t);
  } else {
    // Green to yellow to red (0.5 to 1.0)
    float t = (normalized - 0.5) * 2.0;
    color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), t);
  }

  return vec4(color, 1.0);
}

void
main()
{
  uvec3 tile_coord = gl_GlobalInvocationID.xyz;
  uvec2 tile_count_xy =
    uvec2(ceil(camera_ubo.screen_size_near_far.xy / TILE_SIZE));
  uvec3 tile_grid_size = uvec3(tile_count_xy, NUM_Z_SLICES);

  if (tile_coord.x >= tile_grid_size.x || tile_coord.y >= tile_grid_size.y ||
      tile_coord.z >= tile_grid_size.z)
    return;

  uint tile_index = get_tile_index(tile_coord, tile_grid_size);

  vec2 tile_min =
    vec2(tile_coord.xy) * TILE_SIZE / camera_ubo.screen_size_near_far.xy;
  vec2 tile_max = (vec2(tile_coord.xy) + 1.0) * TILE_SIZE /
                  camera_ubo.screen_size_near_far.xy;

  // Calculate proper depth bounds for this Z-slice
  float far_plane = camera_ubo.screen_size_near_far.w;
  float near_plane = camera_ubo.screen_size_near_far.z;
  float near_depth =
    linear_depth(tile_coord.z, NUM_Z_SLICES, near_plane, far_plane);
  float far_depth =
    linear_depth(tile_coord.z + 1, NUM_Z_SLICES, near_plane, far_plane);

  // Convert to NDC depth [0,1]
  vec4 near_clip = camera_ubo.projection * vec4(0, 0, -near_depth, 1.0);
  vec4 far_clip = camera_ubo.projection * vec4(0, 0, -far_depth, 1.0);
  float near_ndc = (near_clip.z / near_clip.w) * 0.5 + 0.5;
  float far_ndc = (far_clip.z / far_clip.w) * 0.5 + 0.5;

  // Create frustum for this tile
  Frustum tile_frustum =
    create_tile_frustum(tile_min, tile_max, near_ndc, far_ndc);

  // Initialize shared memory - only thread 0 does this
  if (gl_LocalInvocationIndex == 0) {
    shared_count = 0;
  }

  // Wait for shared memory initialization to complete
  barrier();

  // Light culling - test each light against the tile frustum
  uint step_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
  for (uint i = gl_LocalInvocationIndex; i < point_light_buffer.light_count;
       i += step_size) {
    vec3 light_pos = point_light_buffer.lights[i].position;
    float light_radius = point_light_buffer.lights[i].radius;

    // Sphere-frustum intersection test using bounding sphere
    float dist = distance(light_pos, tile_frustum.center);
    if (dist < light_radius + tile_frustum.radius) {
      // Atomically get index and ensure it's within bounds
      uint index = atomicAdd(shared_count, 1);
      if (index < MAX_LIGHTS_PER_TILE) {
        shared_light_indices[index] = i;
      }
    }
  }

  // Ensure all light culling operations complete before proceeding
  barrier();

  // Only thread 0 writes the final results
  if (gl_LocalInvocationIndex == 0) {
    // Clamp count to maximum to handle overflow case
    uint count = min(shared_count, MAX_LIGHTS_PER_TILE);
    uint offset = atomicAdd(global_light_list_counter, count);

    // Write tile grid data
    tile_light_grids[tile_index].offset = offset;
    tile_light_grids[tile_index].count = count;

    // Copy light indices to global buffer
    for (uint j = 0; j < count; ++j) {
      light_indices[offset + j] = shared_light_indices[j];
    }

    // Generate debug visualization
    vec4 heatmap_color = get_heatmap_color(count, MAX_LIGHTS_PER_TILE);

    // Convert to uint color (0-255 range) for rgba8ui format
    uvec4 debug_color = uvec4(uint(heatmap_color.r * 255.0),
                              uint(heatmap_color.g * 255.0),
                              uint(heatmap_color.b * 255.0),
                              255u);

    // Write to entire tile area in debug image (pixel-by-pixel coverage)
    ivec2 tile_pixel_min = ivec2(tile_coord.xy * TILE_SIZE);
    ivec2 tile_pixel_max = ivec2((tile_coord.xy + 1u) * TILE_SIZE);

    // Fill the entire tile with the heatmap color
    for (int y = tile_pixel_min.y; y < tile_pixel_max.y; ++y) {
      for (int x = tile_pixel_min.x; x < tile_pixel_max.x; ++x) {
        imageStore(debug_image, ivec2(x, y), debug_color);
      }
    }
  }
}